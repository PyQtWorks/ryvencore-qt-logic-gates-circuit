{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the ryvencore-qt documentation! Looking for a quick start? Visit the Getting Started section. Project Idea ryvencore-qt is an easy to use framework for creating based flow-based visual scripting editors for Python with Qt. The core concepts of Ryven are now implemented in ryvencore (backend) and ryvencore-qt (frontend) and will be the base also for Ryven itself from now on. Warning ryvencore-qt is not a professional piece of software and sometimes there are major changes. It is in very early stage, and be aware that future versions might not be fully backwards compatible. If you have suggestions for improvement of the software, feel free to open discussions. Besides essential GUI classes, ryvencore-qt also provides a few convenience GUI classes which only use ryvencore's public API, making it a little easier to get started. There is a precise definition of the fundamental characteristics of the flows in the Features section. Current State In it's current state ryvencore-qt (as well as ryvencore) is still experimental. It works well so far and I will use it to create a few more specific visual scripting editors for Python. But it's pretty much in alpha state. Resources May I also point to the website of the Ryven project if you haven't been there already. And there's a small YouTube channel .","title":"Welcome"},{"location":"#welcome-to-the-ryvencore-qt-documentation","text":"Looking for a quick start? Visit the Getting Started section.","title":"Welcome to the ryvencore-qt documentation!"},{"location":"#project-idea","text":"ryvencore-qt is an easy to use framework for creating based flow-based visual scripting editors for Python with Qt. The core concepts of Ryven are now implemented in ryvencore (backend) and ryvencore-qt (frontend) and will be the base also for Ryven itself from now on. Warning ryvencore-qt is not a professional piece of software and sometimes there are major changes. It is in very early stage, and be aware that future versions might not be fully backwards compatible. If you have suggestions for improvement of the software, feel free to open discussions. Besides essential GUI classes, ryvencore-qt also provides a few convenience GUI classes which only use ryvencore's public API, making it a little easier to get started. There is a precise definition of the fundamental characteristics of the flows in the Features section.","title":"Project Idea"},{"location":"#current-state","text":"In it's current state ryvencore-qt (as well as ryvencore) is still experimental. It works well so far and I will use it to create a few more specific visual scripting editors for Python. But it's pretty much in alpha state.","title":"Current State"},{"location":"#resources","text":"May I also point to the website of the Ryven project if you haven't been there already. And there's a small YouTube channel .","title":"Resources"},{"location":"api/","text":"API Reference [class] Session A session is the top-most interface to your components. Usually you will want to create one session per application instance, but you could create multiple ones to have different independent environments in one application. Signals The following signals are useful if you use custom widgets for listing the scripts. You can connect these signals to the corresponding GUI classes to make your GUI adapt. These signals equally apply on function-scripts. Name Parameters Description new_script_created Script Emitted when a new script is created. script_renamed Script Emitted when a script has been renamed. script_deleted Script Emitted when a script has been deleted. Attributes Name Description nodes A list of all registered nodes. design The session's Design reference. Methods Session(threaded: bool = False, gui_parent: QWidget = None, flow_theme_name=None, performance_mode=None, data_conn_class=None, data_conn_item_class=None, exec_conn_class=None, exec_conn_item_class=None, parent: QObject = None) Parameter Description threaded: bool = False True for threaded applications. gui_parent: QObject = None The parent (i.e. MainWindow) for the GUI, only important for threaded applications flow_theme_name The name of the flow theme used performance_mode 'pretty' or 'fast' data_conn_class=None A ref to your custom implementation of DataConnection if you want to provide one. data_conn_item_class=None A ref to your custom implementation of DataConnectionItem if you want to provide one. exec_conn_class=None A ref to your custom implementation of ExecConnection if you want to provide one. exec_conn_item_class=None A ref to your custom implementation of ExecConnectionItem if you want to provide one. parent: QObject = None The session's parent object. This list (and especially the order) might get changed in the future multiple times, so make sure you always use the parameter names. Also, while I think subclassing the connection classes is a great feature, the default class's implementations are young and might receive changes in the future. register_node(node) Registers a Node which then can be accessed in all scripts, Note You can register nodes at any time! register_nodes(node_classes: list) Convenience class for registering a list of nodes at once. unregister_node(node_class) Unregisters a node which will then be removed from the internal list. Existing instances won't be affected. create_script(title: str, flow_view_size: list = None, create_default_logs=True) -> Script Parameter Description title The title of the new script. Script titles have to be unique. flow_view_size the pixel size of the flow in format [x, y] . create_default_logs Indicates whether the script's default logs ( Global and Errors ) should get created. You can also do this later manually via Script.logger.create_default_logs() . Creates and returns a script which triggers the Session.new_script_created() signal. By the time the script is returned, all abstract as well as the GUI components have been created. create_func_script(title: str, flow_view_size: list = None, create_default_logs=True) -> Script Same thing as Session.create_script() for FunctionScript s. all_scripts() -> list Returns a list containing all scripts and function scripts. check_new_script_title_validity(title: str) -> bool Checks whether a considered title for a new script (i.e. unique) is valid or not. rename_script(script: Script, title: str) Renames an existing script which triggers the Session.script_renamed signal. delete_script(script: Script) Deletes a script and triggers the Session.script_deleted signal. load(project: dict) -> bool Loads a project, which means creating all scripts saved in the provided project dict and building all their contents including the flows. serialize() -> dict Returns the project as dict to be saved and loaded again using load(). info_messenger() Returns a reference to the InfoMsgs class for printing only if info messages are enabled. all_nodes() -> list Returns a list of all Node instances (objects) from all flows of the session's scripts. set_stylesheet(s: str) Sets the session's global stylesheet which can be accessed by nodes and their widgets. [class] InfoMsgs The InfoMsgs class just provides a convenient way to print, such that the additional info is disabled by default but can be enabled for troubleshooting. Methods enable() Enables the printing. disable() Disables the printing. write(*args) Writes a list of arguments stringified using str() in the same format print() does. write_err(*args) Same as write(*args) but for highlighted errors. [class] Script Attributes Name Description session a ref to the session flow the script's flow flow view the script's flow view, which is the GUI representative of the flow logger the script's logger vars_manager the script's vars manager for managing the script variables title the script's current tile The FunctionScript class used for function scripts extends the Script 's functionality by a few things such as input node and output node that get added automatically to the flow. [class] Logger The logger manages all the logs of a script. Signals Name Parameters Description new_log_created Log Emitted when a new Log has been created, either manually through new_log() or automatically (default logs). Attributes Name Description script: Script A ref to the script. logs: list A list of all the logs registered in the script. Methods create_default_logs() Creates the default script's logs Global and Errors . This is done automatically if you didn't disable default logs when creating the the script. log_message(msg: str, target: str = '') Logs a message to all logs with name target . If you want to print to a specific log individual log (not one of the default logs), you should use the Log.write() method. new_log(title: str) -> Log Creates an individual new log which you can use for anything. Emits the new_log_created signal. [class] Log Signals The following signals are useful if you implement your own log GUI. Connect them to your widget so it catches those events. Name Parameters Description enabled - Emitted when the log has been enabled. For instance when a Node which requested the log was removed from the flow and has been restored through an undo command, the logs get 'reenabled'. disabled - Emitted when the log has been disabled. For instance when a Node which requested the log has been removed from the flow. wrote str Emitted when something wrote a message to the log. cleared - Emitted when the log has been cleared. Attributes Name Description title: str The log's title string. lines: [str] A list of all logged strings (doesn't get cleared when the log gets cleared). current_lines: [str] All current lines , i.e. the ones that haven't been cleared. Methods write(*args) Writes a list of arguments to the log like print() does, stringifying everything using str() . clear() Clears the log and emits cleared . This doesn't clear the lines attribute! disable() Disables the log and emits disabled . A disabled log does not write anymore. enable() Enables the log and emits enabled . save_to_file(filepath: str, all_lines=True) Saves lines to a file. If all_lines is False it only saves current_lines . [class] VarsManager Signals The following signals are useful if you implement your own script vars list GUI. Name Parameters Description new_var_created Variable Emitted when a new script variable has been created. var_deleted Variable Emitted when a script variable has been deleted. var_val_changed Variable, object Emitted when a script variable's value has been changed. Attributes Name Description variables: [Variable] A list of all the managed script vars. Methods check_new_var_name_validity(name: str) -> bool Checks whether name is a valid name for a new script variable. create_new_var(name: str, val=None) -> Variable Creates and returns a new script variable with given name and initial value. Emits the new_var_created signal. get_var(name) -> Variable Returns script variable with given name or None if it couldn't be found. get_var_val(name) Returns the value of a script variable with given name or None if it couldn't be found. set_var(name, val) -> bool Sets the value of an existing script variable. Returns False if the var couldn't be found. delete_variable(var: Variable) Deletes a script variable and emits var_deleted . register_receiver(receiver, var_name: str, method) Registers a var receiver. A registered receiver (method) gets triggered every time the value of a variable with the given name changes (also when it gets created). unregister_receiver(receiver, var_name: str) -> bool Unregisters a var receiver. [class] Flow The Flow class represents the abstract flow (no GUI) and stores all the node objects and connections. You can access a script's flow via Script.flow . Signals Name Parameters Emitted when... node_added Node a node has been added (also happens when a reoved node is restored through an undo). node_removed Node a node has been removed. connection_added Connection a connection has been added. connection_removed Connection a connection has been removed. algorithm_mode_changed str the flow's algorithm mode changed, see set_algorithm_mode() . Attributes Name Description nodes: [Node] A list of all currently present nodes. connections: [Connection] A list of all current connections. Methods create_node(node_class, config=None) Creates, adds and returns a new node object; emits node_added. remove_node(node: Node) Removes a node from internal list without deleting it; emits node_removed. algorithm_mode() -> str Returns the flow's current algorithms mode ( data for data flow or exec for execution flow ). By default, flows run in data flow mode. set_algorithm_mode(mode: str) Parameter Description mode 'data' or 'exec' [class] FlowView The FlowView is the GUI representative for the Flow , i.e. the widget, and is accessible via Script.flow_view . get_viewport_img() -> QImage Returns a clear image of the viewport. get_whole_scene_img() -> QImage Returns an image of the whole scene, scaled accordingly to current scale factor. Bug Currently, this only works from the viewport's position down and right, so the user has to scroll to the top left corner in order to get the full scene. show_framerate(show: bool = True, m_sec_interval: int = 1000) WIP [class] Node Nodes are defined by subclasses of Node . The individual objects will be instances of the according class. The Node class contains the whole API for programming nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PrintNode ( rc . Node ): title = 'Print' description = 'prints your data' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Static Attributes Use the following static attributes to define the basic properties of your node. Name Description title: str The Node's initial title. It doesn't have to be unique. type_: str Optional way to specify the node. init_inputs: [NodeInput] Initial inputs. init_outputs: [NodeOutput] Initial outputs. identifier: str A unique identifier string. If nothing is provided, the node's class name will be used. description: str A description shown as tool tip when hovering about the node. description_html: str A description in html format. main_widget_class: list A reference to the class of the main_widget if used. main_widget_pos: str 'between ports' or 'below ports' if a main_widget is used. input_widget_classes: dict A dict for custom input widgets in format {name: class} which can then be used when defining initial data inputs or creating ones at runtime. style: str 'extended' (default) or 'small' . Those are the two different design styles for nodes. color: str A color in hex format. icon: str The file path to an icon. Methods [override] update_event(input_called=-1) Triggered when the Node is activated, usually through Node.update() . Example An arr get Node's update event could look like this: 1 2 3 4 def update_event ( self , input_called =- 1 ): arr = self . input ( 0 ) index = self . input ( 1 ) self . set_output_val ( 0 , arr [ index ]) [override] get_data() -> dict In this method, you need to provide all your internal data that defines your Node's current state (if there are different states). The dict will be encoded using pickle and base64 when copying nodes (via ctrl+c) or when saving the project. You do the reverse in Node.set_data(data) (see below). Example Example for a + Node with a dynamic number of inputs, which can be changed by the user. 1 2 3 def get_data ( self ): data = { 'num inputs' : self . num_inputs } return data [override] set_data(data: dict) Parameter Description data Holds the exact value you returned in Node.get_data() . Here you do the reverse of what you did in Node.get_data() . Important Note that all ryvencore internal objects, such as the special_actions dict, as well as inputs and outputs get saved and restored automatically by ryvencore exactly as they were when the flow was saved. So, if you added some inputs for example, don't add them again manually in set_data() according to your attribute which indicates how many you added, this happens automatically. Just update your own internal variables. Example 1 2 def set_data ( self , data ): self . num_inputs = data [ 'num inputs' ] [override] place_event() Triggered when the Node has been added to the flow and all GUI has been initialized . Don't try to access GUI components in the constructor, they don't exist yet, use this method instead. [override] remove_event() Triggered when the Node is removed from the flow. You can use this method do stop threads and timers etc. Note that this action might be undone by an undo operation by the user, in this case the exact Node object will just be placed again resulting in a place_event() . Example Example from a clock Node running a timer. 1 2 def remove_event ( self ): self . timer . stop () update(input_called=-1) Parameter Description input_called If the Node is active, living in an exec flow, i.e. if it has exec inputs, you might want to pass the input the update is supposed to refer to. Triggers an update event. input(index: int) Returns the data that is at the data input with given index. If the input is not connected, the input will return the widget's data (if it has a widget), otherwise it will return the data from the output of the connected Node. In all other cases, it returns None . exec_output(index: int) Parameter Description index Index of the output. It has to be an exec output. Executes the output with given index. set_output_val(index: int, val) Parameter Description index Index of the output. It has to be a data output. val The data that gets set at the output. This can be anything. In dataflows, this causes update events in all connected nodes. This way, change of data is forward propagated through all nodes that depend on it. new_log(title: str) -> Log Parameter Description title The log's display title. Creates and returns a new log, owned by the Node. disable_logs() Disables all logs owned by the Node. The convenience Log widget ryvencore provides then can be hidden. All logs owned by a Node automatically get disabled when the Node is removed. enable_logs() Enables all logs owned by the Node. The convenience Log widget ryvencore provides then shows the widget again, in case it has been hidden after it was disabled. All logs owned by a Node automatically get enabled again when a removed Node is restored through an undo operation. log_message(msg: str, target: str) Parameter Description msg The message as string. target 'Global' or 'Errors' . Refers to one of the script's default logs. update_shape() Causes recompilation of the whole shape of the GUI item of the node. create_input(type_: str = 'data', label: str = '', widget_name=None, widget_pos='besides', pos=-1, ...) Parameter Description type_ 'data' or 'exec' label The input's displayed label string. widget_name The name the input widget has been registered under. None means no widget gets used. widget_pos 'besides' or 'below' the port. pos The index this input should be inserted at. -1 means appending at the end. delete_input(i) Deletes the input at index i . All existing connections get removed automatically. create_output(type_: str = 'data', label: str = '', pos=-1) Parameter Description type_ 'data' or 'exec' label The output's displayed label string. pos The index this output should be inserted at. -1 means appending at the end. delete_output(o) Deletes the output at index o . All existing connections get removed automatically. session_stylesheet() -> str Returns the stylesheet registered via Session.set_stylesheet() . This can be useful for custom widgets. get_var_val(name: str) Parameter Description name script variable's name Returns the current value of a script variable and None if it couldn't be found. set_var_val(name: str, val) Parameter Description name script variable's name val the variable's value Sets the value of a script variable and causes all registered receivers to update (see below). register_var_receiver(name: str, method) Parameter Description name script variable's name method a reference to the receiver method Registers a method as receiver for changes of script variable with given name. Example 1 2 3 4 # connect to variable changes # self.var_val_updated refers to the receiver method self . register_var_receiver ( 'x' , self . var_val_updated ) self . used_variable_names . append ( 'x' ) unregister_var_receiver(name: str) Unregisters a previously registered variable receiver.","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#class-session","text":"A session is the top-most interface to your components. Usually you will want to create one session per application instance, but you could create multiple ones to have different independent environments in one application.","title":"[class] Session"},{"location":"api/#signals","text":"The following signals are useful if you use custom widgets for listing the scripts. You can connect these signals to the corresponding GUI classes to make your GUI adapt. These signals equally apply on function-scripts. Name Parameters Description new_script_created Script Emitted when a new script is created. script_renamed Script Emitted when a script has been renamed. script_deleted Script Emitted when a script has been deleted.","title":"Signals"},{"location":"api/#attributes","text":"Name Description nodes A list of all registered nodes. design The session's Design reference.","title":"Attributes"},{"location":"api/#methods","text":"","title":"Methods"},{"location":"api/#class-infomsgs","text":"The InfoMsgs class just provides a convenient way to print, such that the additional info is disabled by default but can be enabled for troubleshooting.","title":"[class] InfoMsgs"},{"location":"api/#methods_1","text":"","title":"Methods"},{"location":"api/#class-script","text":"","title":"[class] Script"},{"location":"api/#attributes_1","text":"Name Description session a ref to the session flow the script's flow flow view the script's flow view, which is the GUI representative of the flow logger the script's logger vars_manager the script's vars manager for managing the script variables title the script's current tile The FunctionScript class used for function scripts extends the Script 's functionality by a few things such as input node and output node that get added automatically to the flow.","title":"Attributes"},{"location":"api/#class-logger","text":"The logger manages all the logs of a script.","title":"[class] Logger"},{"location":"api/#signals_1","text":"Name Parameters Description new_log_created Log Emitted when a new Log has been created, either manually through new_log() or automatically (default logs).","title":"Signals"},{"location":"api/#attributes_2","text":"Name Description script: Script A ref to the script. logs: list A list of all the logs registered in the script.","title":"Attributes"},{"location":"api/#methods_2","text":"","title":"Methods"},{"location":"api/#class-log","text":"","title":"[class] Log"},{"location":"api/#signals_2","text":"The following signals are useful if you implement your own log GUI. Connect them to your widget so it catches those events. Name Parameters Description enabled - Emitted when the log has been enabled. For instance when a Node which requested the log was removed from the flow and has been restored through an undo command, the logs get 'reenabled'. disabled - Emitted when the log has been disabled. For instance when a Node which requested the log has been removed from the flow. wrote str Emitted when something wrote a message to the log. cleared - Emitted when the log has been cleared.","title":"Signals"},{"location":"api/#attributes_3","text":"Name Description title: str The log's title string. lines: [str] A list of all logged strings (doesn't get cleared when the log gets cleared). current_lines: [str] All current lines , i.e. the ones that haven't been cleared.","title":"Attributes"},{"location":"api/#methods_3","text":"","title":"Methods"},{"location":"api/#class-varsmanager","text":"","title":"[class] VarsManager"},{"location":"api/#signals_3","text":"The following signals are useful if you implement your own script vars list GUI. Name Parameters Description new_var_created Variable Emitted when a new script variable has been created. var_deleted Variable Emitted when a script variable has been deleted. var_val_changed Variable, object Emitted when a script variable's value has been changed.","title":"Signals"},{"location":"api/#methods_4","text":"","title":"Methods"},{"location":"api/#class-flow","text":"The Flow class represents the abstract flow (no GUI) and stores all the node objects and connections. You can access a script's flow via Script.flow .","title":"[class] Flow"},{"location":"api/#signals_4","text":"Name Parameters Emitted when... node_added Node a node has been added (also happens when a reoved node is restored through an undo). node_removed Node a node has been removed. connection_added Connection a connection has been added. connection_removed Connection a connection has been removed. algorithm_mode_changed str the flow's algorithm mode changed, see set_algorithm_mode() .","title":"Signals"},{"location":"api/#methods_5","text":"","title":"Methods"},{"location":"api/#class-flowview","text":"The FlowView is the GUI representative for the Flow , i.e. the widget, and is accessible via Script.flow_view .","title":"[class] FlowView"},{"location":"api/#class-node","text":"Nodes are defined by subclasses of Node . The individual objects will be instances of the according class. The Node class contains the whole API for programming nodes. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class PrintNode ( rc . Node ): title = 'Print' description = 'prints your data' init_inputs = [ rc . NodeInput ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data )","title":"[class] Node"},{"location":"api/#static-attributes","text":"Use the following static attributes to define the basic properties of your node. Name Description title: str The Node's initial title. It doesn't have to be unique. type_: str Optional way to specify the node. init_inputs: [NodeInput] Initial inputs. init_outputs: [NodeOutput] Initial outputs. identifier: str A unique identifier string. If nothing is provided, the node's class name will be used. description: str A description shown as tool tip when hovering about the node. description_html: str A description in html format. main_widget_class: list A reference to the class of the main_widget if used. main_widget_pos: str 'between ports' or 'below ports' if a main_widget is used. input_widget_classes: dict A dict for custom input widgets in format {name: class} which can then be used when defining initial data inputs or creating ones at runtime. style: str 'extended' (default) or 'small' . Those are the two different design styles for nodes. color: str A color in hex format. icon: str The file path to an icon.","title":"Static Attributes"},{"location":"api/#methods_6","text":"","title":"Methods"},{"location":"features/","text":"Features Flows - A Rigurous Definition A flow is like a directed multigraph (not necessarily acyclic) whose vertices are nodes with connections as edges to other nodes. The fundamental actions that can be performed on a flow are adding a node removing a node and all incident connections adding a connection between ports of two different nodes removing an existing connection Standard flow execution (for data flows) is defined as follows: By calling Node.set_output_val(index, val) , every outgoing connection is activated , with val as payload, which leads to an update event in every connected node. No automatic modification is performed on val . If there are multiple connections, the order of activation is the order in which they have been added. exec flows There are two types of connections, namely data and exec , and hence two types of node ports. Usually you will want to only use data connections and ports (-> data flows ). For execution connections, by calling Node.exec_output(index) , the same happens as for data propagation described above, just that there is no val payload. In both cases does the input_called parameter in Node.update_event represent the input index that received data, or a signal from an activated connection. The mode of a flow ( data or exec ) can be set at any time using Flow.set_algorithm_mode , default is data . Nodes System Nodes are subclasses of the Node class. Single node instances are instances of their class, and the basic properties that apply on all those nodes equally are stored as static attributes. Individually changing properties are inputs and outputs (which can be added, removed and modified at any time), display title, actions (see below) etc. You can put any code into your node classes, no limitations, and for sophisticated use you can override the default behavior by reimplementing methods. Special Actions Special actions are a very simple way to define right click operations for your nodes. The non-static Node.special_actions attribute is a dictionary which you can edit like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # creating a new entry self . special_actions [ 'add some input' ] = { 'method' : self . add_some_input_action } # with a corresponding method def add_some_input_action ( self ): self . create_input ( type_ = 'data' , label = 'new input' ) # removing an entry del self . special_actions [ 'add some input' ] # and storing individual data for multiple actions pointing to the same target method # which enables dynamic, current state dependent actions self . special_actions [ 'add some input at index 0' ] = { 'method' : self . add_some_input_at , 'data' : 0 } self . special_actions [ 'add some input at index 1' ] = { 'method' : self . add_some_input_at , 'data' : 1 } def add_some_input_at ( self , index ): self . create_input ( type_ = 'data' , label = 'inserted input' , pos = index ) Special actions are saved and reloaded automatically. Load&Save To save a project, simply use Session.serialize() , to load a saved project use Session.load() . Before loading a project, you need to register all required nodes in the session. Script Variables Script variables are a nice way to improve the interface to your data. There is a really simple but extremely powerful registration system that you can use to register methods as receivers for a variable with a given name. Then, every time the variable's value gets updated, all registered receiver methods are called. The registration process is part of the API of the Node class, so you can easily create highly responsive nodes. Example I made a small Matrix node in Ryven where you can just type a few numbers into a small textedit (which is the custom main_widget of the node) and it creates a numpy array out of them. But you can also type in the name of a script variable somewhere (instead of a number) which makes the matrix node register as a receiver, so it updates and regenerates the matrix every time the value of a script variable with that name updated. Note You could also work with default variables, for example, that you always create when creating a new script, by default, which all your nodes use to communicate or transmit data in more complex ways. This illustrates, there is really a bunch of quite interesting possibilities for sophisticated optimization with this. The system might be expanded in the future. Logging There is a Logger class which every script has an instance of. You can use the logger's API to write messages to default logs and to request custom logs and write directly to them. The Node 's API already includes methods for requesting custom logs and manages enable -and disable -events according to actions in the flow (like removing the Node), but you can also request logs for anything else. Styling Of course, design splays a huge role when thinking about visual scripting. Therefore, you have wide freedom in styling. Flow Themes There is a list of available flow themes (which I want to expand as far as possible). You can choose one via Session.design.set_flow_theme() . Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . To make sure you can create a look that fits in nicely wherever you might integrate your editor, you can customize the colors for all the above themes using a config json file and passing it to the design using Sessiong.design.load_from_config(filepath) . The json file should look like this, for any value you can either write \"default\" or specify a specific setting according to the instructions in the info box. config file You can also specify the initial flow theme, the performance mode ( 'pretty' or 'fast' ) and animations (which currently don't work I think). You can just copy the following json, save it in a file and specify. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 { \"init flow theme\" : \"Samuel 1l\" , \"init performance mode\" : \"pretty\" , \"init animations enabled\" : true , \"flow themes\" : { \"Toy\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Tron\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Ghost\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" , \"small nodes color\" : \"default\" }, \"Blender\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" }, \"Simple\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Ueli\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Samuel 1d\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" }, \"Samuel 1l\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" } } } Also note that the syntax of these configurations might receive some changes in the future. Give non-default values for widths in number format, not str . Possible values for pen styles are solid line , dash line , dash dot line , dash dot dot line and dot line . Give color as string in hex format (also compatible with alpha values like #aabb4499 ). StyleSheets The styling of widgets is pretty much in your hands. You can also store a stylesheet via Session.design.set_stylesheet() which is then accessible in custom node widget classes via self.session.design.global_stylesheet . When making a larger editor, you can style the builtin widgets (like the builtin input widgets for nodes) by referencing their class names in your qss. Customizing Connections You can provide your own reimplementations of the connection classes, since this is an excellent point to add domain-specific additional functionality to your editor (like 'edge weights' for example). There are no detailed instructions on that in the docs yet, but you can take a look at the implementations, and then pass your implementations of the classes you want to enhance to the Session 's constructor, see API . Flow View Features The FlowView class, which is a subclass of QGraphicsView , supports some special features such as stylus support for adding simple handwritten notes rendered images of the flow including high res for presentations Threading The internal communication between backend and frontend is done in a somewhat thread-safe way. This means, you can initialize the Session object in a separate thread, and provide a GUI parent for the flow view, which will then be initialized in this GUI component's thread. This generally speeds up the backend and makes sure it's not significantly affected by performance fluctuations of the frontend. Further parallelization of the tasks that your individual nodes perform is up to you. Note Be careful with calling Session.serialize() from different threads simultaneously, as the serialization of the FlowView is currently \"joined\" with the session's thread by setting an attribute (see Session.serialize() implementation). GUI-less Deployment When you saved a project in your editor (via Session.serialize() ), you can reload it using ryvencore (the backend) manually to deploy your flows anywhere. You have full access to the whole ryvencore API, so you can even perform modifications with the expected results. So, GUI-less deployment is like code generation but better, since you still have API access. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if __name__ == '__main__' : with open ( 'path/to/your/project_file' , 'r' ) as f : project_str = f . read () project_dict = json . loads ( project_str ) # creating session and loading the contents session = Session ( no_gui = True ) session . register_nodes ([ < your_used_nodes_here > ]) function_scripts , scripts = session . load ( project_dict ) # now you have manual access like this... myscript = scripts [ 0 ] myflow = script . flow node1 , node2 , node3 = flow . nodes node1 . update () Which of the API calls you use in ryvencore-qt are from ryvencore is indicated in the API reference. Of course, your nodes are not allowed to access ryvencore-qt API, as this API does not exist when running it on the backend, since there is no frontend then. To make your nodes compatible with this, you can use check the Session.no_gui attribute to determine whether the session is having a frontend or not. 1 2 3 4 5 6 7 8 def update_event ( self , input_called =- 1 ): # doing some work if self . session . gui : self . main_widget () . update () # setting some outputs Currently, when running it in GUI mode, ryvencore uses Qt signals so the frontend is notified when events like placement of a node in a flow happen. When running ryvencore without frontend, these signals do nothing, so there is no Qt dependency then. This dualism is planned to get replaced in the future by something more scalable, possibly a brokerless message queue to easily enable network scaling.","title":"Features"},{"location":"features/#features","text":"","title":"Features"},{"location":"features/#flows-a-rigurous-definition","text":"A flow is like a directed multigraph (not necessarily acyclic) whose vertices are nodes with connections as edges to other nodes. The fundamental actions that can be performed on a flow are adding a node removing a node and all incident connections adding a connection between ports of two different nodes removing an existing connection Standard flow execution (for data flows) is defined as follows: By calling Node.set_output_val(index, val) , every outgoing connection is activated , with val as payload, which leads to an update event in every connected node. No automatic modification is performed on val . If there are multiple connections, the order of activation is the order in which they have been added.","title":"Flows - A Rigurous Definition"},{"location":"features/#exec-flows","text":"There are two types of connections, namely data and exec , and hence two types of node ports. Usually you will want to only use data connections and ports (-> data flows ). For execution connections, by calling Node.exec_output(index) , the same happens as for data propagation described above, just that there is no val payload. In both cases does the input_called parameter in Node.update_event represent the input index that received data, or a signal from an activated connection. The mode of a flow ( data or exec ) can be set at any time using Flow.set_algorithm_mode , default is data .","title":"exec flows"},{"location":"features/#nodes-system","text":"Nodes are subclasses of the Node class. Single node instances are instances of their class, and the basic properties that apply on all those nodes equally are stored as static attributes. Individually changing properties are inputs and outputs (which can be added, removed and modified at any time), display title, actions (see below) etc. You can put any code into your node classes, no limitations, and for sophisticated use you can override the default behavior by reimplementing methods.","title":"Nodes System"},{"location":"features/#special-actions","text":"Special actions are a very simple way to define right click operations for your nodes. The non-static Node.special_actions attribute is a dictionary which you can edit like this 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # creating a new entry self . special_actions [ 'add some input' ] = { 'method' : self . add_some_input_action } # with a corresponding method def add_some_input_action ( self ): self . create_input ( type_ = 'data' , label = 'new input' ) # removing an entry del self . special_actions [ 'add some input' ] # and storing individual data for multiple actions pointing to the same target method # which enables dynamic, current state dependent actions self . special_actions [ 'add some input at index 0' ] = { 'method' : self . add_some_input_at , 'data' : 0 } self . special_actions [ 'add some input at index 1' ] = { 'method' : self . add_some_input_at , 'data' : 1 } def add_some_input_at ( self , index ): self . create_input ( type_ = 'data' , label = 'inserted input' , pos = index ) Special actions are saved and reloaded automatically.","title":"Special Actions"},{"location":"features/#loadsave","text":"To save a project, simply use Session.serialize() , to load a saved project use Session.load() . Before loading a project, you need to register all required nodes in the session.","title":"Load&amp;Save"},{"location":"features/#script-variables","text":"Script variables are a nice way to improve the interface to your data. There is a really simple but extremely powerful registration system that you can use to register methods as receivers for a variable with a given name. Then, every time the variable's value gets updated, all registered receiver methods are called. The registration process is part of the API of the Node class, so you can easily create highly responsive nodes. Example I made a small Matrix node in Ryven where you can just type a few numbers into a small textedit (which is the custom main_widget of the node) and it creates a numpy array out of them. But you can also type in the name of a script variable somewhere (instead of a number) which makes the matrix node register as a receiver, so it updates and regenerates the matrix every time the value of a script variable with that name updated. Note You could also work with default variables, for example, that you always create when creating a new script, by default, which all your nodes use to communicate or transmit data in more complex ways. This illustrates, there is really a bunch of quite interesting possibilities for sophisticated optimization with this. The system might be expanded in the future.","title":"Script Variables"},{"location":"features/#logging","text":"There is a Logger class which every script has an instance of. You can use the logger's API to write messages to default logs and to request custom logs and write directly to them. The Node 's API already includes methods for requesting custom logs and manages enable -and disable -events according to actions in the flow (like removing the Node), but you can also request logs for anything else.","title":"Logging"},{"location":"features/#styling","text":"Of course, design splays a huge role when thinking about visual scripting. Therefore, you have wide freedom in styling.","title":"Styling"},{"location":"features/#flow-themes","text":"There is a list of available flow themes (which I want to expand as far as possible). You can choose one via Session.design.set_flow_theme() . Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . To make sure you can create a look that fits in nicely wherever you might integrate your editor, you can customize the colors for all the above themes using a config json file and passing it to the design using Sessiong.design.load_from_config(filepath) . The json file should look like this, for any value you can either write \"default\" or specify a specific setting according to the instructions in the info box. config file You can also specify the initial flow theme, the performance mode ( 'pretty' or 'fast' ) and animations (which currently don't work I think). You can just copy the following json, save it in a file and specify. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 { \"init flow theme\" : \"Samuel 1l\" , \"init performance mode\" : \"pretty\" , \"init animations enabled\" : true , \"flow themes\" : { \"Toy\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Tron\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" }, \"Ghost\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" , \"small nodes color\" : \"default\" }, \"Blender\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes color\" : \"default\" }, \"Simple\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Ueli\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"nodes background color\" : \"default\" , \"small nodes background color\" : \"default\" }, \"Samuel 1d\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" }, \"Samuel 1l\" : { \"exec connection color\" : \"default\" , \"exec connection width\" : \"default\" , \"exec connection pen style\" : \"default\" , \"data connection color\" : \"default\" , \"data connection width\" : \"default\" , \"data connection pen style\" : \"default\" , \"flow background color\" : \"default\" , \"extended node background color\" : \"default\" , \"small node background color\" : \"default\" , \"node title color\" : \"default\" , \"port pin pen color\" : \"default\" } } } Also note that the syntax of these configurations might receive some changes in the future. Give non-default values for widths in number format, not str . Possible values for pen styles are solid line , dash line , dash dot line , dash dot dot line and dot line . Give color as string in hex format (also compatible with alpha values like #aabb4499 ).","title":"Flow Themes"},{"location":"features/#stylesheets","text":"The styling of widgets is pretty much in your hands. You can also store a stylesheet via Session.design.set_stylesheet() which is then accessible in custom node widget classes via self.session.design.global_stylesheet . When making a larger editor, you can style the builtin widgets (like the builtin input widgets for nodes) by referencing their class names in your qss.","title":"StyleSheets"},{"location":"features/#customizing-connections","text":"You can provide your own reimplementations of the connection classes, since this is an excellent point to add domain-specific additional functionality to your editor (like 'edge weights' for example). There are no detailed instructions on that in the docs yet, but you can take a look at the implementations, and then pass your implementations of the classes you want to enhance to the Session 's constructor, see API .","title":"Customizing Connections"},{"location":"features/#flow-view-features","text":"The FlowView class, which is a subclass of QGraphicsView , supports some special features such as stylus support for adding simple handwritten notes rendered images of the flow including high res for presentations","title":"Flow View Features"},{"location":"features/#threading","text":"The internal communication between backend and frontend is done in a somewhat thread-safe way. This means, you can initialize the Session object in a separate thread, and provide a GUI parent for the flow view, which will then be initialized in this GUI component's thread. This generally speeds up the backend and makes sure it's not significantly affected by performance fluctuations of the frontend. Further parallelization of the tasks that your individual nodes perform is up to you. Note Be careful with calling Session.serialize() from different threads simultaneously, as the serialization of the FlowView is currently \"joined\" with the session's thread by setting an attribute (see Session.serialize() implementation).","title":"Threading"},{"location":"features/#gui-less-deployment","text":"When you saved a project in your editor (via Session.serialize() ), you can reload it using ryvencore (the backend) manually to deploy your flows anywhere. You have full access to the whole ryvencore API, so you can even perform modifications with the expected results. So, GUI-less deployment is like code generation but better, since you still have API access. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if __name__ == '__main__' : with open ( 'path/to/your/project_file' , 'r' ) as f : project_str = f . read () project_dict = json . loads ( project_str ) # creating session and loading the contents session = Session ( no_gui = True ) session . register_nodes ([ < your_used_nodes_here > ]) function_scripts , scripts = session . load ( project_dict ) # now you have manual access like this... myscript = scripts [ 0 ] myflow = script . flow node1 , node2 , node3 = flow . nodes node1 . update () Which of the API calls you use in ryvencore-qt are from ryvencore is indicated in the API reference. Of course, your nodes are not allowed to access ryvencore-qt API, as this API does not exist when running it on the backend, since there is no frontend then. To make your nodes compatible with this, you can use check the Session.no_gui attribute to determine whether the session is having a frontend or not. 1 2 3 4 5 6 7 8 def update_event ( self , input_called =- 1 ): # doing some work if self . session . gui : self . main_widget () . update () # setting some outputs Currently, when running it in GUI mode, ryvencore uses Qt signals so the frontend is notified when events like placement of a node in a flow happen. When running ryvencore without frontend, these signals do nothing, so there is no Qt dependency then. This dualism is planned to get replaced in the future by something more scalable, possibly a brokerless message queue to easily enable network scaling.","title":"GUI-less Deployment"},{"location":"getting_started/","text":"Getting Started Installation 1 pip install ryvencore-qt or from sources 1 2 3 git clone https://github.com/leon-thomm/ryvencore-qt cd ryvencore-qt python setup.py install Python 3.8+ recommended First Editor Info You can copy the full example code at the bottom of this page. Let's build our first editor. First thing is importing the library 1 import ryvencore_qt as rc Overall Structure Your main interface to the current project is the Session , which basically represents a project. We can leave everything as default for now. 1 my_session = rc . Session () Now let's create a flow, which is part of a Script . Scripts are managed by the session and contain the flow , script variables and the logs . 1 script = my_session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) With the flow_view_size you can set the pixel size of the flow view that will be created. You can access the view via my_session.flow_views(script) . The flow itself is a QGraphicsView subclass, which is a GUI class of Qt. Setting Up a Window This is not a tutorial on getting started with Qt for Python, but setting up a basic GUI structure is quite simple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ryvencore - qt as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () session . design . set_flow_theme ( name = 'Samuel 1l' ) # registering the nodes session . register_nodes ([ PrintNode , RandNode ]) # creating a script with a flow script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( session . flow_views [ script ]) mw . show () sys . exit ( app . exec_ ()) And there we go, that's it. You can left click into the scene to see a node selection widget pop up. Well, there isn't any content yet to use, so let's add that. Nodes In ryvencore the nodes system works like this: A node's blueprint is defined by its class, making heavy use of Pythons static attributes system. As the accessible nodes are managed by the session, you need to register the classes of the nodes you want to use like this: 1 session . register_nodes ( list_of_nodes ) Notice You can put any code into your Node subclass, no limits! You can define additional classes, use external packages, basically everything you can do in a python class. Hint You can register (and unregister) nodes at any time! This enables dynamic import mechanisms as implemented in Ryven for example. Now let's define a simple node. For a detailed description of the members, take a look into the API reference . We'll just create a very simple print node, which prints data from an input every time it receives some. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Make your class derive from rc.Node and then enhance it the way you like. The update_event is the important part, it gets triggered every time the node is supposed to update. Note While most flow-based visual scripting software out there implements either the approach of execution-flows or data-flows , ryvencore implements them both. Generally, data flows are more flexible and powerful, so the focus is on them, but there are cases where exec flows make more sense, so I wanted to leave it as an option. Custom Node Base Class In more sophisticated editors, you may want to define your custom NodeBase class to add functionality to all your nodes. If you want ryvencore-internal nodes (like function nodes) to be children of this class too, you can provide your base class when initializing the Session object. And let's add another node which generates a random number in a given range, so we have something to print. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import random class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInputBP ( 'data' , '' , { 'widget name' : 'std line edit' , 'widget pos' : 'besides' }) ] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random float between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) Note the widget -related specs in the NodePort which I will explain in the following section. Input Widgets Data inputs can have widgets, more specifically a QWidget (which is a GUI class of Qt) or a subclass. Custom input widget classes can be registered for a node by listing them in the Node's static field input_widget_classes (see API ). However, ryvencore-qt also provides a few builtin convenience classes. The following code creates an input with an input field of the builtin type std line edit . 1 2 3 init_inputs = [ rc . NodeInputBP ( 'data' , '' , { 'widget name' : 'std line edit' , 'widget pos' : 'besides' }) ] Finishing Now you can run this and if everything works fine you already have a small editor with all major features. You can place the two nodes, connect them by mouse, type something into the random node's input field and hit enter to trigger the update. This will cause the self.set_output_val(...) call which triggers the connected print node to update and print. Of course there is much more you can do. For example you can change the flow theme. 1 session . design . set_flow_theme ( name = 'Samuel 1l' ) Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . And if that's not enough, you can configure the theme colors for those using a json config file, so you'll definitely be able to give your flows a look that fits in the application environment it's going to be a part of. You can also change the performance mode to fast which results in some changes in rendering. 1 session . design . set_performance_mode ( 'fast' ) CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import ryvencore_qt as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication from random import random class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInputBP ( 'data' , '' , { 'widget name' : 'std line edit' , 'widget pos' : 'besides' }) ] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random float between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () session . design . set_flow_theme ( name = 'Samuel 1l' ) # registering the nodes session . register_nodes ([ PrintNode , RandNode ]) # creating a script with a flow script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( session . flow_views [ script ]) mw . show () sys . exit ( app . exec_ ()) Second Editor Here I will just throw at you the commented code for another editor that demonstrates how slightly larger ryvencore-qt editors might generally be structured. It was a first prototype I made for a software to simulate flows of logic gates. CODE main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import ryvencore_qt as rc import sys from PySide2.QtWidgets import QApplication , QMainWindow , QHBoxLayout , QWidget # nodes.py is defined below from nodes import SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , \\ NodeBase class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () # if I wanted to make all ryvencore-internally defined nodes # (like function nodes) also inherit from our NodeBase, I'd provide # it as node_class parameter here, but I dont want that in this case self . session = rc . Session () # some design specs self . session . design . set_flow_theme ( name = 'Samuel 1l' ) self . session . design . set_performance_mode ( 'pretty' ) # registering the nodes self . session . register_nodes ( [ SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , ] ) self . script = self . session . create_script ( title = 'main' ) view = self . session . flow_views [ self . script ] # creating a widget and adding the flow view of the script w = QWidget () w . setLayout ( QHBoxLayout ()) w . layout () . addWidget ( view ) self . setCentralWidget ( w ) self . resize ( 1500 , 800 ) # resizing the window if __name__ == '__main__' : app = QApplication () mw = MainWindow () mw . show () sys . exit ( app . exec_ ()) nodes.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 import ryvencore_qt as rc # some Qt imports... from PySide2.QtGui import Qt from PySide2.QtWidgets import QCheckBox , QPushButton class NodeBase ( rc . Node ): \"\"\"Base class for the nodes in this application\"\"\" style = 'small' color = '#cc7777' class SignalNode_MainWidget ( rc . MWB , QCheckBox ): \"\"\"Custom MainWidget for the signal node, just a simple check box for now. Note that QCheckBox is a QWidget. Also note that we must also derive rc.MWB, the MainWidgetBase of ryvencore_qt.\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QCheckBox . __init__ ( self ) self . stateChanged . connect ( self . node . update_signal ) def get_data ( self ) -> dict : # saving the checked state return { 'checked' : self . checkState () } def set_data ( self , data : dict ): # reloading the checked state self . setChecked ( data [ 'checked' ]) class SignalNode ( NodeBase ): \"\"\"A node for generating high or low voltage signals.\"\"\" title = 'signal' description = 'creates a signal, 1 or 0' init_inputs = [] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] main_widget_class = SignalNode_MainWidget main_widget_pos = 'between ports' # alternatively 'below ports' style = 'extended' def __init__ ( self , params ): super () . __init__ ( params ) self . signal_high = False def update_signal ( self , state ): self . signal_high = True if state == Qt . Checked else False self . update () def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . signal_high )) # note that 1 and 0 can be interpreted as True and False # by all the logical operators that these nodes use def get_data ( self ) -> dict : # saving signal state return { 'signal high' : self . signal_high } def set_data ( self , data ): # reloading signal state self . signal_high = data [ 'signal high' ] class ANDGateNode ( NodeBase ): title = 'AND' description = '1 <=> both inputs are 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) and self . input ( 1 ))) class ORGateNode ( NodeBase ): title = 'OR' description = '1 <=> at least one input is 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) or self . input ( 1 ))) class XORGateNode ( NodeBase ): title = 'XOR' description = '1 <=> odd number of inputs is 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) != self . input ( 1 ))) class NOTGateNode ( NodeBase ): title = 'NOT' description = 'negates the signal' init_inputs = [ rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not self . input ( 0 ))) class NANDGateNode ( NodeBase ): title = 'NAND' description = 'NOT AND' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) and self . input ( 1 )))) class NORGateNode ( NodeBase ): title = 'NOR' description = 'NOT OR' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) or self . input ( 1 )))) class LED_MainWidget ( rc . MWB , QPushButton ): \"\"\"LED widget for the LED node, for now just a simple disabled button\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) self . setEnabled ( False ) self . setFixedSize ( 70 , 50 ) self . setStyleSheet ( self . gen_style_sheet ( False )) def gen_style_sheet ( self , high_potential : bool ): # generate stylesheet with red or transparent background return f ''' QPushButton {{ border: 1px solid transparent; background: { ( 'red' if high_potential else 'transparent' ) } ; }} ''' def potential_updated ( self , high_potential : bool ): # called from self.node self . setStyleSheet ( self . gen_style_sheet ( high_potential )) class LEDNode ( NodeBase ): title = 'LED' description = 'shows red if signal is 1, black if it is 0' init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] main_widget_class = LED_MainWidget main_widget_pos = 'between ports' def update_event ( self , input_called =- 1 ): # note that such unchecked calls to GUI components are not allowed in nodes # that are intended to run on ryvencore without GUI. But because this isn't # really a use case here, we can keep it simple for now mw = self . main_widget () mw . potential_updated ( bool ( self . input ( 0 ))) And now we have a basic little editor to play around with logic gates, yayy! The actual editor I made for this is a bit more sophisticated and beautiful, and might get its own repository soon. Congrats, you are now good to go to create much more advanced and optimized editors. ryvencore-qt has much more features than I showed here. See the Features section where you will find more detailed descriptions of all the internal systems, from save&load over stylus-and touch-support to execution flows. The world is yours, have fun!","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"getting_started/#installation","text":"1 pip install ryvencore-qt or from sources 1 2 3 git clone https://github.com/leon-thomm/ryvencore-qt cd ryvencore-qt python setup.py install Python 3.8+ recommended","title":"Installation"},{"location":"getting_started/#first-editor","text":"Info You can copy the full example code at the bottom of this page. Let's build our first editor. First thing is importing the library 1 import ryvencore_qt as rc","title":"First Editor"},{"location":"getting_started/#overall-structure","text":"Your main interface to the current project is the Session , which basically represents a project. We can leave everything as default for now. 1 my_session = rc . Session () Now let's create a flow, which is part of a Script . Scripts are managed by the session and contain the flow , script variables and the logs . 1 script = my_session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) With the flow_view_size you can set the pixel size of the flow view that will be created. You can access the view via my_session.flow_views(script) . The flow itself is a QGraphicsView subclass, which is a GUI class of Qt.","title":"Overall Structure"},{"location":"getting_started/#setting-up-a-window","text":"This is not a tutorial on getting started with Qt for Python, but setting up a basic GUI structure is quite simple. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import ryvencore - qt as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () session . design . set_flow_theme ( name = 'Samuel 1l' ) # registering the nodes session . register_nodes ([ PrintNode , RandNode ]) # creating a script with a flow script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( session . flow_views [ script ]) mw . show () sys . exit ( app . exec_ ()) And there we go, that's it. You can left click into the scene to see a node selection widget pop up. Well, there isn't any content yet to use, so let's add that.","title":"Setting Up a Window"},{"location":"getting_started/#nodes","text":"In ryvencore the nodes system works like this: A node's blueprint is defined by its class, making heavy use of Pythons static attributes system. As the accessible nodes are managed by the session, you need to register the classes of the nodes you want to use like this: 1 session . register_nodes ( list_of_nodes ) Notice You can put any code into your Node subclass, no limits! You can define additional classes, use external packages, basically everything you can do in a python class. Hint You can register (and unregister) nodes at any time! This enables dynamic import mechanisms as implemented in Ryven for example. Now let's define a simple node. For a detailed description of the members, take a look into the API reference . We'll just create a very simple print node, which prints data from an input every time it receives some. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) Make your class derive from rc.Node and then enhance it the way you like. The update_event is the important part, it gets triggered every time the node is supposed to update. Note While most flow-based visual scripting software out there implements either the approach of execution-flows or data-flows , ryvencore implements them both. Generally, data flows are more flexible and powerful, so the focus is on them, but there are cases where exec flows make more sense, so I wanted to leave it as an option. Custom Node Base Class In more sophisticated editors, you may want to define your custom NodeBase class to add functionality to all your nodes. If you want ryvencore-internal nodes (like function nodes) to be children of this class too, you can provide your base class when initializing the Session object. And let's add another node which generates a random number in a given range, so we have something to print. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from random import random class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInputBP ( 'data' , '' , { 'widget name' : 'std line edit' , 'widget pos' : 'besides' }) ] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random float between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) Note the widget -related specs in the NodePort which I will explain in the following section.","title":"Nodes"},{"location":"getting_started/#finishing","text":"Now you can run this and if everything works fine you already have a small editor with all major features. You can place the two nodes, connect them by mouse, type something into the random node's input field and hit enter to trigger the update. This will cause the self.set_output_val(...) call which triggers the connected print node to update and print. Of course there is much more you can do. For example you can change the flow theme. 1 session . design . set_flow_theme ( name = 'Samuel 1l' ) Currently available flow themes are Samuel 1d , Samuel 1l , Samuel 2d , Samuel 2l , Ueli , Blender , Simple , Toy and Tron . And if that's not enough, you can configure the theme colors for those using a json config file, so you'll definitely be able to give your flows a look that fits in the application environment it's going to be a part of. You can also change the performance mode to fast which results in some changes in rendering. 1 session . design . set_performance_mode ( 'fast' ) CODE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import ryvencore_qt as rc import sys from PySide2.QtWidgets import QMainWindow , QApplication from random import random class PrintNode ( rc . Node ): # all basic properties title = 'Print' description = 'prints your data' # there is also description_html init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] color = '#A9D5EF' # see API doc for a full list of all properties # we could also skip the constructor here def __init__ ( self , params ): super () . __init__ ( params ) def update_event ( self , input_called =- 1 ): data = self . input ( 0 ) # get data from the first input print ( data ) class RandNode ( rc . Node ): title = 'Rand' description = 'generates random float' init_inputs = [ rc . NodeInputBP ( 'data' , '' , { 'widget name' : 'std line edit' , 'widget pos' : 'besides' }) ] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] color = '#fcba03' def update_event ( self , input_called =- 1 ): # random float between 0 and value at input val = random () * self . input ( 0 ) # setting the value of the first output self . set_output_val ( 0 , val ) if __name__ == \"__main__\" : # create a QApplication and a MainWindow # the QMainWindow will be subclassed later app = QApplication () mw = QMainWindow () # creating the session session = rc . Session () session . design . set_flow_theme ( name = 'Samuel 1l' ) # registering the nodes session . register_nodes ([ PrintNode , RandNode ]) # creating a script with a flow script = session . create_script ( 'hello world' , flow_view_size = [ 800 , 500 ]) # and setting the flow widget as the windows central widget mw . setCentralWidget ( session . flow_views [ script ]) mw . show () sys . exit ( app . exec_ ())","title":"Finishing"},{"location":"getting_started/#second-editor","text":"Here I will just throw at you the commented code for another editor that demonstrates how slightly larger ryvencore-qt editors might generally be structured. It was a first prototype I made for a software to simulate flows of logic gates. CODE main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import ryvencore_qt as rc import sys from PySide2.QtWidgets import QApplication , QMainWindow , QHBoxLayout , QWidget # nodes.py is defined below from nodes import SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , \\ NodeBase class MainWindow ( QMainWindow ): def __init__ ( self ): super () . __init__ () # if I wanted to make all ryvencore-internally defined nodes # (like function nodes) also inherit from our NodeBase, I'd provide # it as node_class parameter here, but I dont want that in this case self . session = rc . Session () # some design specs self . session . design . set_flow_theme ( name = 'Samuel 1l' ) self . session . design . set_performance_mode ( 'pretty' ) # registering the nodes self . session . register_nodes ( [ SignalNode , ANDGateNode , ORGateNode , NANDGateNode , NORGateNode , NOTGateNode , XORGateNode , LEDNode , ] ) self . script = self . session . create_script ( title = 'main' ) view = self . session . flow_views [ self . script ] # creating a widget and adding the flow view of the script w = QWidget () w . setLayout ( QHBoxLayout ()) w . layout () . addWidget ( view ) self . setCentralWidget ( w ) self . resize ( 1500 , 800 ) # resizing the window if __name__ == '__main__' : app = QApplication () mw = MainWindow () mw . show () sys . exit ( app . exec_ ()) nodes.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 import ryvencore_qt as rc # some Qt imports... from PySide2.QtGui import Qt from PySide2.QtWidgets import QCheckBox , QPushButton class NodeBase ( rc . Node ): \"\"\"Base class for the nodes in this application\"\"\" style = 'small' color = '#cc7777' class SignalNode_MainWidget ( rc . MWB , QCheckBox ): \"\"\"Custom MainWidget for the signal node, just a simple check box for now. Note that QCheckBox is a QWidget. Also note that we must also derive rc.MWB, the MainWidgetBase of ryvencore_qt.\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QCheckBox . __init__ ( self ) self . stateChanged . connect ( self . node . update_signal ) def get_data ( self ) -> dict : # saving the checked state return { 'checked' : self . checkState () } def set_data ( self , data : dict ): # reloading the checked state self . setChecked ( data [ 'checked' ]) class SignalNode ( NodeBase ): \"\"\"A node for generating high or low voltage signals.\"\"\" title = 'signal' description = 'creates a signal, 1 or 0' init_inputs = [] init_outputs = [ rc . NodeOutputBP ( 'data' ) ] main_widget_class = SignalNode_MainWidget main_widget_pos = 'between ports' # alternatively 'below ports' style = 'extended' def __init__ ( self , params ): super () . __init__ ( params ) self . signal_high = False def update_signal ( self , state ): self . signal_high = True if state == Qt . Checked else False self . update () def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . signal_high )) # note that 1 and 0 can be interpreted as True and False # by all the logical operators that these nodes use def get_data ( self ) -> dict : # saving signal state return { 'signal high' : self . signal_high } def set_data ( self , data ): # reloading signal state self . signal_high = data [ 'signal high' ] class ANDGateNode ( NodeBase ): title = 'AND' description = '1 <=> both inputs are 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) and self . input ( 1 ))) class ORGateNode ( NodeBase ): title = 'OR' description = '1 <=> at least one input is 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) or self . input ( 1 ))) class XORGateNode ( NodeBase ): title = 'XOR' description = '1 <=> odd number of inputs is 1' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( self . input ( 0 ) != self . input ( 1 ))) class NOTGateNode ( NodeBase ): title = 'NOT' description = 'negates the signal' init_inputs = [ rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not self . input ( 0 ))) class NANDGateNode ( NodeBase ): title = 'NAND' description = 'NOT AND' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) and self . input ( 1 )))) class NORGateNode ( NodeBase ): title = 'NOR' description = 'NOT OR' init_inputs = [ rc . NodeInputBP ( 'data' ), rc . NodeInputBP ( 'data' ), ] init_outputs = [ rc . NodeOutputBP ( 'data' ), ] def update_event ( self , input_called =- 1 ): self . set_output_val ( 0 , int ( not ( self . input ( 0 ) or self . input ( 1 )))) class LED_MainWidget ( rc . MWB , QPushButton ): \"\"\"LED widget for the LED node, for now just a simple disabled button\"\"\" def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) self . setEnabled ( False ) self . setFixedSize ( 70 , 50 ) self . setStyleSheet ( self . gen_style_sheet ( False )) def gen_style_sheet ( self , high_potential : bool ): # generate stylesheet with red or transparent background return f ''' QPushButton {{ border: 1px solid transparent; background: { ( 'red' if high_potential else 'transparent' ) } ; }} ''' def potential_updated ( self , high_potential : bool ): # called from self.node self . setStyleSheet ( self . gen_style_sheet ( high_potential )) class LEDNode ( NodeBase ): title = 'LED' description = 'shows red if signal is 1, black if it is 0' init_inputs = [ rc . NodeInputBP ( 'data' ) ] init_outputs = [] main_widget_class = LED_MainWidget main_widget_pos = 'between ports' def update_event ( self , input_called =- 1 ): # note that such unchecked calls to GUI components are not allowed in nodes # that are intended to run on ryvencore without GUI. But because this isn't # really a use case here, we can keep it simple for now mw = self . main_widget () mw . potential_updated ( bool ( self . input ( 0 ))) And now we have a basic little editor to play around with logic gates, yayy! The actual editor I made for this is a bit more sophisticated and beautiful, and might get its own repository soon. Congrats, you are now good to go to create much more advanced and optimized editors. ryvencore-qt has much more features than I showed here. See the Features section where you will find more detailed descriptions of all the internal systems, from save&load over stylus-and touch-support to execution flows. The world is yours, have fun!","title":"Second Editor"},{"location":"gui/","text":"GUI Adding intuitive GUI to your nodes is of mayor importance to create a nice interface. Therefore, in ryvencore you can register your very own widget classes and are not restricted to some fixed set of available standard widgets. However, there are also a few convenience widgets which make your life a lot easier. Convenience GUI Classes All those classes only use ryvencore's public API and you could implement them all yourself. The list should grow over time. All these are classes come from Ryven. Script List Widget A simple list widget for creating, renaming and deleting scripts and function-scripts. To catch the according events (i.e. script_created , script_renamed etc), use the signals of the Session class. Variables List Widget A synchronous widget to the script list widget for script variables. You can create, rename, delete script variables and change their values which results in all registered receivers to update. Log Widget A very basic widget for outputting data of a log. Use the Script.logger.new_log_created() signal to catch instantiation of new logs. If you want to implement your own, you will need the Log 's signals enabled , disabled , cleared , wrote . Input Widgets std line edit aka std line edit m , std line edit s , std line edit l std spin box For styling those, refer to thir classes RCIW_BUILTIN_LineEdit , RCIW_BUILTIN_SpinBox . I really would like to add many more widgets to this list in the future. Writing your own GUI All custom widgets must be QWidgets and subclass one of ryvencore's widget base classes. Both classes have similar functionality for serialization and loading as Node . They have methods get_data() -> dict and set_data(data: dict) (and also a remove_event() right now) to subclass. Main Widget A main widget must additionally subclass ryvencore's MWB (MainWidgetBase) class. Example: 1 2 3 4 5 6 7 8 9 10 11 12 import ryvencore_qt as rc from PySide2.QtWidgets import QPushButton class MyMainWidget ( rc . MWB , QPushButton ): def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) # then do your stuff like self . setEnabled ( False ) self . clicked . connect ( self . node . update ) After rc.MWB.__init__(self, params) , you have access to the node object via self.node . A custom main widget class must be referenced in the node's class definition 1 2 3 4 5 6 7 8 9 10 11 class MyNode ( rc . Node ): title = '...' # ... main_widget_class = MyMainWidget # ... def __init__ ( self , params ): super () . __init__ ( params ) # ... Input Widget An input widget must additionally subclass ryvencore's IWB (InputWidgetBase) class. The initialization process is exactly the same as with MWB shown in the example above. After the IWB constructor the refs self.node to the node object and self.input for the node's input port object which contains the widget are available. Custom input widget classes, together with the names that should be used to refer to them node internally, must be referenced in the node's class definition 1 2 3 4 5 6 7 8 9 10 11 class MyNode ( rc . Node ): title = '...' # ... input_widget_classes = { 'some input widget' : MyInputWidget } # ... def __init__ ( self , params ): super () . __init__ ( params ) # ...","title":"GUI"},{"location":"gui/#gui","text":"Adding intuitive GUI to your nodes is of mayor importance to create a nice interface. Therefore, in ryvencore you can register your very own widget classes and are not restricted to some fixed set of available standard widgets. However, there are also a few convenience widgets which make your life a lot easier.","title":"GUI"},{"location":"gui/#convenience-gui-classes","text":"All those classes only use ryvencore's public API and you could implement them all yourself. The list should grow over time. All these are classes come from Ryven.","title":"Convenience GUI Classes"},{"location":"gui/#script-list-widget","text":"A simple list widget for creating, renaming and deleting scripts and function-scripts. To catch the according events (i.e. script_created , script_renamed etc), use the signals of the Session class.","title":"Script List Widget"},{"location":"gui/#variables-list-widget","text":"A synchronous widget to the script list widget for script variables. You can create, rename, delete script variables and change their values which results in all registered receivers to update.","title":"Variables List Widget"},{"location":"gui/#log-widget","text":"A very basic widget for outputting data of a log. Use the Script.logger.new_log_created() signal to catch instantiation of new logs. If you want to implement your own, you will need the Log 's signals enabled , disabled , cleared , wrote .","title":"Log Widget"},{"location":"gui/#input-widgets","text":"std line edit aka std line edit m , std line edit s , std line edit l std spin box For styling those, refer to thir classes RCIW_BUILTIN_LineEdit , RCIW_BUILTIN_SpinBox . I really would like to add many more widgets to this list in the future.","title":"Input Widgets"},{"location":"gui/#writing-your-own-gui","text":"All custom widgets must be QWidgets and subclass one of ryvencore's widget base classes. Both classes have similar functionality for serialization and loading as Node . They have methods get_data() -> dict and set_data(data: dict) (and also a remove_event() right now) to subclass.","title":"Writing your own GUI"},{"location":"gui/#main-widget","text":"A main widget must additionally subclass ryvencore's MWB (MainWidgetBase) class. Example: 1 2 3 4 5 6 7 8 9 10 11 12 import ryvencore_qt as rc from PySide2.QtWidgets import QPushButton class MyMainWidget ( rc . MWB , QPushButton ): def __init__ ( self , params ): rc . MWB . __init__ ( self , params ) QPushButton . __init__ ( self ) # then do your stuff like self . setEnabled ( False ) self . clicked . connect ( self . node . update ) After rc.MWB.__init__(self, params) , you have access to the node object via self.node . A custom main widget class must be referenced in the node's class definition 1 2 3 4 5 6 7 8 9 10 11 class MyNode ( rc . Node ): title = '...' # ... main_widget_class = MyMainWidget # ... def __init__ ( self , params ): super () . __init__ ( params ) # ...","title":"Main Widget"},{"location":"gui/#input-widget","text":"An input widget must additionally subclass ryvencore's IWB (InputWidgetBase) class. The initialization process is exactly the same as with MWB shown in the example above. After the IWB constructor the refs self.node to the node object and self.input for the node's input port object which contains the widget are available. Custom input widget classes, together with the names that should be used to refer to them node internally, must be referenced in the node's class definition 1 2 3 4 5 6 7 8 9 10 11 class MyNode ( rc . Node ): title = '...' # ... input_widget_classes = { 'some input widget' : MyInputWidget } # ... def __init__ ( self , params ): super () . __init__ ( params ) # ...","title":"Input Widget"},{"location":"threading/","text":"Threading First, I want to mention that the system is often subject to frequent changes, and especially the exact way in which nodes communicate with their widgets using signals and slots as described below might change drastically in the future to enable more scalable deployment. The instructions described here only apply on threaded applications. Overview One of the biggest internal changes in ryvencore, compared to Ryven 2, is threading compatibility. ryvencore provides abstract components and the GUI for the flows, so in order to run a session instance inside a threaded application, the internal communication between those components must be set up in a thread save way. In ryvencore this is currently done using Qt's standard signals and slots system. Characteristics You should be careful with accessing session contents from multiple different threads simultaneously. There are API methods that trigger procedures in the GUI components (like initialization) and wait wait for them to complete. To ensure that these procedures complete during the execution of the according API method, the calling abstract component (like Script ) uses a temp attribute which it sets to None before triggering the intended procedure in the GUI thread via a signal, and then waits for this attribute to be set to something else by the component executing the procedure in the main/GUI thread. Programming Nodes A Node object lives in the same thread as the Session . Their GUI items, however, including all custom widgets , live in the GUI thread. Therefore, you need to make sure that the communication between your nodes and their custom widgets is thread save, which usually means implemented using Qt's signals and slots. Communication from Nodes to Widgets If your node needs to send signals to the widgets, there currently is a SIGNALS class part of Node , which you can reimplement, which will be instantiated during initialization and can be accessed through the attribute Node.signals . Connections from the node to the widgets are supposed to be built in the Node 's place_event() . Note The Node 's place_event() method is called once the node has been initialized and all GUI has too, so I suggest using it only for connecting to the GUI. Concretely, it works like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ryvencore_qt as rc from PySide2.QtCore import QObject , Signal class MyNode ( rc . Node ): title = '...' description = '...' # ... class SIGNALS ( QObject ): my_signal = Signal ( object ) def place_event ( self ): self . signals . my_signal . connect ( self . main_widget () . some_method ) def update_event ( self , input_called =- 1 ): # ... self . signals . my_signal . emit ( something ) # ... Communication from Widgets to Nodes For custom widgets, since QWidgets are QObjects, you can directly add all your signals as static attributes to your custom widget class. Further Thoughts I want to mention that ryvencore could probably be modified easily to run without any GUI. Furthermore, all abstract components, such as Session , Script , Flow etc. only have dependency to Qt's signals right now. Depending on in which environments ryvencore should run in the future, there might be mayor changes to the communication system in the future, to make it more scalable. If you want to contribute to this, you can try to modify ryvencore such that it can easily run without GUI. The advantage of using something else than Qt's signals and slots could be that in case running ryvencore without GUI is a frequent use case, this could be done without any Qt dependencies at all. For thoughts and showcases on this, feel free to open issues and discussions.","title":"Threading"},{"location":"threading/#threading","text":"First, I want to mention that the system is often subject to frequent changes, and especially the exact way in which nodes communicate with their widgets using signals and slots as described below might change drastically in the future to enable more scalable deployment. The instructions described here only apply on threaded applications.","title":"Threading"},{"location":"threading/#overview","text":"One of the biggest internal changes in ryvencore, compared to Ryven 2, is threading compatibility. ryvencore provides abstract components and the GUI for the flows, so in order to run a session instance inside a threaded application, the internal communication between those components must be set up in a thread save way. In ryvencore this is currently done using Qt's standard signals and slots system.","title":"Overview"},{"location":"threading/#characteristics","text":"You should be careful with accessing session contents from multiple different threads simultaneously. There are API methods that trigger procedures in the GUI components (like initialization) and wait wait for them to complete. To ensure that these procedures complete during the execution of the according API method, the calling abstract component (like Script ) uses a temp attribute which it sets to None before triggering the intended procedure in the GUI thread via a signal, and then waits for this attribute to be set to something else by the component executing the procedure in the main/GUI thread.","title":"Characteristics"},{"location":"threading/#programming-nodes","text":"A Node object lives in the same thread as the Session . Their GUI items, however, including all custom widgets , live in the GUI thread. Therefore, you need to make sure that the communication between your nodes and their custom widgets is thread save, which usually means implemented using Qt's signals and slots.","title":"Programming Nodes"},{"location":"threading/#communication-from-nodes-to-widgets","text":"If your node needs to send signals to the widgets, there currently is a SIGNALS class part of Node , which you can reimplement, which will be instantiated during initialization and can be accessed through the attribute Node.signals . Connections from the node to the widgets are supposed to be built in the Node 's place_event() . Note The Node 's place_event() method is called once the node has been initialized and all GUI has too, so I suggest using it only for connecting to the GUI. Concretely, it works like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import ryvencore_qt as rc from PySide2.QtCore import QObject , Signal class MyNode ( rc . Node ): title = '...' description = '...' # ... class SIGNALS ( QObject ): my_signal = Signal ( object ) def place_event ( self ): self . signals . my_signal . connect ( self . main_widget () . some_method ) def update_event ( self , input_called =- 1 ): # ... self . signals . my_signal . emit ( something ) # ...","title":"Communication from Nodes to Widgets"},{"location":"threading/#communication-from-widgets-to-nodes","text":"For custom widgets, since QWidgets are QObjects, you can directly add all your signals as static attributes to your custom widget class.","title":"Communication from Widgets to Nodes"},{"location":"threading/#further-thoughts","text":"I want to mention that ryvencore could probably be modified easily to run without any GUI. Furthermore, all abstract components, such as Session , Script , Flow etc. only have dependency to Qt's signals right now. Depending on in which environments ryvencore should run in the future, there might be mayor changes to the communication system in the future, to make it more scalable. If you want to contribute to this, you can try to modify ryvencore such that it can easily run without GUI. The advantage of using something else than Qt's signals and slots could be that in case running ryvencore without GUI is a frequent use case, this could be done without any Qt dependencies at all. For thoughts and showcases on this, feel free to open issues and discussions.","title":"Further Thoughts"}]}